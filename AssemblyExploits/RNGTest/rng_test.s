#Random number generator test using Lehmer linear random number generator algorithm
#z = (a*z+b) mod m = (31*z+13)%19683
.section .data
b:
	.int 13
m:
	.int 19683
a:
	.int 31
SCORE:
	.int 6
COUNTER:
	.int 2
DIVISOR:
	.int 32767
MAKEWHOLE:
	.int 100

.section .text
.globl _start
_start:
	nop
	jmp random4

#Test 1 = Failed due to seg fault (suspected edx reg overwritten by mull)
#random1:
#        movl $43962, %edx
#	 loop random
#        movl %eax, %edx 	#Segfault could be caused by wrong orientation of registers
#        movl $31, %ebx
#        mull %ebx
#        addl $13, %eax
#        movl $19683, %ebx
#        divl %ebx
#	pushl %ebx
#        call printf
#        addl $8, %esp
#	movl $1, %eax
#	movl $0, %ebx
#	 dec %ecx
#        int $0x80

#Test 2 = use the call rand function in assembly
#Two random numbers between 0-100
#random2:
#	mov $SCORE, %ebx
#	mov $0, %esi
#loop_ax:
#	call rand
#	mov $100, %edx
#	idiv %edx
#	mov %edx, (%ebx)
#	
#	add $4, %ebx
#
#	push %edx
#	call printf
#	add $8, %esp
#	
#	inc %esi
#	cmp $COUNTER, %esi
#	jne loop_ax
#	int $0x80

#Test 3 = trimming down the fat in the YT tutorial to use time stamp division to produce a random number
random3:
#	rdtsc			#EAX now contains the low counter (incremented every clock cycle)
#	shr %eax,2 		#restores fairness in the soloution by shifting bits 
#	add $1, %ebx 		#includes upper bound now
#	sub %ebx, [%ebp+$8] 	#produces the range between 0-100 (100)
#	cdg			#clock tick value (basically a random number determined by the time from rdtsc)...
#	idiv %ebx		#..is divided by the range (remainder is used to give a random number in the range)
#	add %edx,[ebp+8]	#lower bound is added to the number to form number within the range

#	mov $1, %eax
#	mov $100, %ebx

#	rdtsc
#	sar $2, %eax		
#	add $1, %ebx
#	cdg 			#command doesnt exist according to the compiler
#	div %ebx		#shifting bits instead to avoid floating point exceptions
#	sar $50, %eax

#	push %eax
#	call printf
#	add $4, %esp
#	call exit

#Test 4 = trying call rand again
random4:
	mov $100, %eax
#	call time		#causes segfaults
	push %eax
	call rand		#random number between 0 and 32767 is now in eax

	mov $100, %ebx
	div %eax
	mul %ebx
	int $0x80

#Test 5 = using rdrand to create a random number
random5:
	mov $100, %eax	#empty register might fix illegal error
	rdrand %eax	#find random number, put in eax
	mov $100, %ebx	#mov upper bound into non-volatile reg 
	div %ebx	#divide by upper bound
	add $1, %edx	#add 1 to remainder to include upper bound
	int $0x80
